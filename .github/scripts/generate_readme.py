import os
import requests
import re
import time

# --- 設定 ---
PROBLEMS_DIR = "./problems"
README_FILE = "README.md"
LEETCODE_API_URL = "https://leetcode.com/api/problems/all/"
LEETCODE_GRAPHQL_URL = "https://leetcode.com/graphql"

def get_id_slug_map():
    """
    獲取所有題目的 ID -> Slug 對照表。
    這個 API 請求一次，速度很快，用來把 ID 轉成網址 slug。
    """
    print("正在取得 LeetCode 題目列表 (ID mapping)...")
    try:
        headers = {'User-Agent': 'Mozilla/5.0'}
        resp = requests.get(LEETCODE_API_URL, headers=headers, timeout=10)
        data = resp.json()
        
        id_map = {}
        for item in data['stat_status_pairs']:
            stat = item['stat']
            frontend_id = str(stat['frontend_question_id'])
            id_map[frontend_id] = stat['question__title_slug']
        return id_map
    except Exception as e:
        print(f"無法獲取題目列表: {e}")
        return {}

def fetch_problem_details(title_slug):
    """
    針對「單一題目」抓取詳細資訊 (包含 Topic Tags)
    """
    query = """
    query questionData($titleSlug: String!) {
      question(titleSlug: $titleSlug) {
        title
        difficulty
        topicTags {
          name
        }
      }
    }
    """
    payload = {
        "query": query,
        "variables": {"titleSlug": title_slug}
    }
    
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0',
            'Content-Type': 'application/json'
        }
        resp = requests.post(LEETCODE_GRAPHQL_URL, json=payload, headers=headers, timeout=5)
        data = resp.json()
        
        if 'data' in data and data['data']['question']:
            q = data['data']['question']
            return {
                "title": q['title'],
                "difficulty": q['difficulty'],
                "tags": [tag['name'] for tag in q['topicTags']]
            }
    except Exception as e:
        print(f"  抓取詳細資料失敗 ({title_slug}): {e}")
    
    return None

def parse_existing_readme():
    """
    解析現有的 README.md，把已經存在的題目資訊讀出來當作快取。
    """
    existing_data = {} # ID -> {title, difficulty, tags}
    
    if not os.path.exists(README_FILE):
        return existing_data
        
    with open(README_FILE, "r", encoding="utf-8") as f:
        lines = f.readlines()
        
    # 簡單的正則表達式來解析 Markdown 表格行
    # 假設格式: | ID | [Title](link) | Difficulty | Solutions | Topic |
    for line in lines:
        if line.strip().startswith("|") and "---" not in line and "ID" not in line:
            parts = [p.strip() for p in line.split("|")]
            if len(parts) >= 6:
                pid = parts[1]
                
                # 如果 ID 是數字才處理
                if pid.isdigit():
                    # 解析 Title (去除 Markdown 連結語法)
                    raw_title = parts[2]
                    title_match = re.search(r"\[(.*?)\]", raw_title)
                    title = title_match.group(1) if title_match else raw_title
                    
                    difficulty = parts[3]
                    
                    # 解析 Topic
                    tags_str = parts[5]
                    tags = [t.strip() for t in tags_str.split(",")] if tags_str else []
                    
                    existing_data[pid] = {
                        "title": title,
                        "difficulty": difficulty,
                        "tags": tags
                    }
    return existing_data

def scan_local_solutions():
    """掃描本地資料夾"""
    solutions = {} 
    if not os.path.exists(PROBLEMS_DIR):
        return {}

    for folder_name in os.listdir(PROBLEMS_DIR):
        folder_path = os.path.join(PROBLEMS_DIR, folder_name)
        if os.path.isdir(folder_path) and folder_name.isdigit():
            prob_id = str(int(folder_name))
            exts = []
            for file in os.listdir(folder_path):
                if file.startswith("solution."):
                    ext = file.split(".")[-1]
                    if ext in ['py', 'cpp', 'rs', 'c', 'java', 'go', 'js', 'ts']:
                        exts.append(ext)
            if exts:
                solutions[prob_id] = {
                    "folder_name": folder_name,
                    "exts": sorted(exts)
                }
    return solutions

def generate_markdown(final_data, local_solutions, id_slug_map):
    """生成新的 README"""
    content = ["# LeetCode Practice\n"]
    content.append(f"Auto-generated by GitHub Actions. Solved: **{len(local_solutions)}**\n")
    content.append("| ID | Title | Difficulty | Solution | Topic |")
    content.append("|:---|:---|:---|:---|:---|")
    
    sorted_ids = sorted(local_solutions.keys(), key=lambda x: int(x))
    
    for pid in sorted_ids:
        folder_name = local_solutions[pid]['folder_name']
        exts = local_solutions[pid]['exts']
        info = final_data.get(pid, {"title": "Unknown", "difficulty": "-", "tags": []})
        
        # 處理連結 slug
        slug = id_slug_map.get(pid, "")
        title_display = info['title']
        if slug:
            title_display = f"[{info['title']}](https://leetcode.com/problems/{slug}/)"
            
        # 解法連結
        sol_links = []
        ext_map = {'py': 'Python', 'cpp': 'C++', 'rs': 'Rust', 'js': 'JS'}
        for ext in exts:
            lang_name = ext_map.get(ext, ext.upper())
            link = f"[{lang_name}](./problems/{folder_name}/solution.{ext})"
            sol_links.append(link)
        sol_str = " / ".join(sol_links)
        
        tags_str = ", ".join([t for t in info['tags'] if t])
        
        row = f"| {folder_name} | {title_display} | {info['difficulty']} | {sol_str} | {tags_str} |"
        content.append(row)
    
    return "\n".join(content)

if __name__ == "__main__":
    # 1. 取得 ID -> Slug 對照表 (必要，為了產生連結和查詢詳細資料)
    id_map = get_id_slug_map()
    
    # 2. 掃描本地解法
    local_sols = scan_local_solutions()
    
    # 3. 讀取舊的 README 作為快取 (Magic Here!)
    existing_data = parse_existing_readme()
    print(f"從 README 讀取了 {len(existing_data)} 筆舊資料。")
    
    # 4. 合併資料，只抓取缺少的
    final_data = {}
    new_fetch_count = 0
    
    for pid in local_sols:
        # 如果 README 裡已經有資料，且有 Topic (不是空的)，就直接用
        if pid in existing_data and existing_data[pid]['tags']:
            final_data[pid] = existing_data[pid]
        else:
            # 這是新題目，或者舊題目但沒抓過 Topic
            slug = id_map.get(pid)
            if slug:
                print(f"  [New] 正在下載詳細資訊: Problem {pid} ({slug})...")
                details = fetch_problem_details(slug)
                if details:
                    final_data[pid] = details
                    new_fetch_count += 1
                    time.sleep(0.5) # 禮貌性延遲
                else:
                    final_data[pid] = existing_data.get(pid, {"title": "Unknown", "difficulty": "-", "tags": []})
            else:
                print(f"  [Warn] 找不到 ID {pid} 的 Slug")
                final_data[pid] = {"title": "Unknown", "difficulty": "-", "tags": []}
                
    print(f"資料準備完成。新增/更新了 {new_fetch_count} 筆題目的詳細資料。")

    if local_sols:
        md_content = generate_markdown(final_data, local_sols, id_map)
        with open(README_FILE, "w", encoding="utf-8") as f:
            f.write(md_content)
        print(f"成功更新 {README_FILE}！")